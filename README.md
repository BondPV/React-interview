# React-interview

<a id="0"/></a>

[1. Что такое JSX?](#1)

[2. Можно ли использовать React без JSX?](#2)

[3. Что такое виртуальный DOM?](#3)

[4. Является ли виртуальный DOM таким же, как теневой DOM?](#4)

[5. В чем разница между виртуальным DOM и реальным DOM?](#5)

[6. Когда рендерится компонент?](#6)

[7. Как не рендерить при изменении props?](#7)

[8. Можно ли использовать стрелочные функции в методе render()?](#7)

***

<a id="1"/></a>
## 1. Что такое JSX?

**JSX** - это расширение синтаксиса JavaScript, которое позволяет использовать XML-подобный синтаксис для описания структуры пользовательского интерфейса в React. JSX позволяет разработчикам создавать компоненты React, которые могут содержать HTML-подобные теги, атрибуты и дочерние элементы. JSX затем компилируется в обычный JavaScript, который может быть выполнен в браузере. 

**JSX** понимается только препроцессорами, такими как Babel. Когда препроцессор обрабатывает этот текст, похожий на HTML, он преобразуется в обычные функциональные вызовы React.createElement.

> JSX не является частью спецификации ECMAScript, и поэтому ни один веб-браузер не понимает JSX.
JSX - это синтаксический сахар для функции React.createElement.

Вот пример использования JSX в React:

```js
import React from 'react';

function MyComponent() {
  return (
    <div className="my-class">
      <h1>Hello, World!</h1>
      <p>This is my first React component.</p>
    </div>
  );
}
```

В этом примере мы создаем компонент MyComponent, который возвращает JSX-элемент, содержащий теги div, h1 и p. Обратите внимание, что мы используем атрибут className вместо class, потому что class является зарезервированным словом в JavaScript.

[вернуться к списку вопросов](#0)
***

<a id="2"/></a>
## 2. Можно ли использовать React без JSX?

Да, можно использовать React без JSX. JSX - это просто синтаксический сахар, который упрощает написание кода React, но не является обязательным для использования React. Вместо JSX вы можете использовать обычный JavaScript для создания элементов React.

> JSX - это синтаксический сахар для функции React.createElement. React.createElement является частью общедоступного API верхнего уровня React, так же как React.component или React.useRef.

Например, вместо написания:
```js
const element = <h1>Hello, world!</h1>;

// Вы можете написать:

const element = React.createElement('h1', null, 'Hello, world!');
```

Обратите внимание, что React.createElement() возвращает объект React-элемента, который затем может быть отрендерен в DOM.

[вернуться к списку вопросов](#0)
***
<a id="3"/></a>
## 3. Что такое виртуальный DOM? Как React использует виртуальный DOM для рендеринга пользовательского интерфейса?
> Объектная модель документа (Document Object Model, DOM) - это стандартная модель программирования, используемая для представления и взаимодействия с HTML-документами, XML-документами и другими типами документов. DOM представляет документ в виде дерева объектов, где каждый элемент документа является объектом. DOM простыми словами представляет собой пользовательский интерфейс приложения.

> Виртуальный DOM — это виртуальное представление реального DOM.

**Виртуальный DOM (VDOM)** - это концепция, которая используется во многих библиотеках и фреймворках JavaScript, включая React. Он представляет собой абстрактное представление реального DOM, которое хранится в памяти и используется для оптимизации процесса рендеринга.

Когда React обновляет пользовательский интерфейс, он сначала создает новое дерево виртуального DOM на основе изменений в состоянии приложения или свойствах компонентов. Затем React сравнивает новое дерево виртуального DOM с предыдущим деревом и определяет, какие элементы были изменены, добавлены или удалены.

После того, как React определил, какие элементы должны быть обновлены, он создает новый дерево реального DOM и обновляет только те элементы, которые были изменены. Это позволяет избежать необходимости полного перерисовывания всего пользовательского интерфейса и ускоряет процесс рендеринга.

Использование виртуального DOM также позволяет React работать с различными браузерами и платформами, не завися от конкретной реализации реального DOM. Это делает React более переносимым и удобным для разработки кросс-браузерных приложений.

В целом, использование виртуального DOM является одним из ключевых преимуществ React и позволяет создавать быстрые и эффективные пользовательские интерфейсы.

[вернуться к списку вопросов](#0)
***
<a id="4"/></a>
## 4. Является ли виртуальный DOM таким же, как теневой DOM?

**Виртуальный DOM (virtual DOM, VDOM)** - это концепция, используемая в библиотеках и фреймворках, таких как React и Vue, для оптимизации производительности при обновлении пользовательского интерфейса. Виртуальный DOM представляет собой виртуальное дерево элементов, которое React или Vue используют для определения того, какие элементы должны быть обновлены при изменении состояния приложения. Виртуальный DOM позволяет избежать ненужных обновлений и повысить производительность приложения.

**Теневой DOM (shadow DOM)** - это концепция, используемая в браузерах для реализации веб-компонентов. Теневой DOM представляет собой отдельное дерево элементов, которое используется для изоляции стилей и поведения веб-компонента от остальной части страницы. Теневой DOM позволяет создавать компоненты, которые могут быть использованы в разных частях страницы, не влияя на другие элементы на странице.

Таким образом, виртуальный DOM и теневой DOM - это разные концепции, используемые для разных целей.

[вернуться к списку вопросов](#0)
***
<a id="5"/></a>
## 5. В чем разница между виртуальным DOM и реальным DOM?

**Виртуальный DOM (VDOM)** - это концепция, которая используется в библиотеках и фреймворках JavaScript, таких как React и Vue, для ускорения процесса обновления пользовательского интерфейса. Вместо того, чтобы изменять реальный DOM напрямую, библиотеки создают виртуальное представление дерева DOM, которое хранится в памяти. Когда происходят изменения в состоянии приложения, библиотека сравнивает виртуальное дерево с предыдущей версией и определяет, какие элементы необходимо обновить. Затем библиотека обновляет только те элементы, которые изменились, в реальном DOM.

**Реальный DOM** - это фактическое представление дерева DOM, которое браузер создает на основе HTML-кода. Когда происходят изменения в состоянии приложения, библиотеки обновляют реальный DOM, чтобы отобразить эти изменения. Однако обновление реального DOM может быть очень медленным, особенно если в дереве DOM много элементов. Кроме того, обновление реального DOM может привести к перерисовке всего дерева, даже если изменения затрагивают только небольшую часть дерева.

Виртуальный DOM позволяет избежать этих проблем, поскольку он позволяет библиотекам эффективно обновлять только те элементы, которые изменились, и не перерисовывать всё дерево. Это делает обновление пользовательского интерфейса более быстрым и эффективным.

![img](assets/VDOM.png)

[вернуться к списку вопросов](#0)
***
<a id="6"></a>
## 6. Когда рендерится компонент?
Компонент рендерится, когда он вставляется в DOM. Это происходит, когда компонент впервые отображается на странице или когда его состояние или свойства изменяются. Когда компонент рендерится, React создает виртуальное представление дерева DOM, которое затем сравнивается с предыдущей версией, чтобы определить, какие элементы необходимо обновить. Затем React обновляет только те элементы, которые изменились, в реальном DOM.

Компонент может быть перерендерен множество раз во время жизненного цикла приложения, например, когда его состояние или свойства изменяются, или когда он получает новые данные из API. При этом React будет создавать новое виртуальное представление дерева DOM и сравнивать его с предыдущей версией, чтобы определить, какие элементы необходимо обновить. Если изменения затрагивают только небольшую часть дерева, то React обновит только эту часть, что делает обновление пользовательского интерфейса более быстрым и эффективным.

[вернуться к списку вопросов](#0)
***
<a id="7"></a>
## Как не рендерить при изменении props?
> Использовать метод жизненного цикла **shouldComponentUpdate()**

Этот метод вызывается перед каждым обновлением компонента и позволяет определить, должен ли компонент быть перерендерен или нет.

В методе shouldComponentUpdate() вы можете сравнить текущие свойства (props) компонента с предыдущими свойствами и вернуть false, если свойства не изменились и компонент не должен быть перерендерен. Если свойства изменились, вы можете вернуть true, чтобы разрешить перерендеринг компонента.

Вот пример использования метода shouldComponentUpdate() для предотвращения перерендеривания компонента при изменении определенных свойств:
```js
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps) {
    if (nextProps.prop1 === this.props.prop1 && nextProps.prop2 === this.props.prop2) {
      return false; // не перерендеривать компонент, если prop1 и prop2 не изменились
    }
    return true; // перерендеривать компонент, если prop1 или prop2 изменились
  }

  render() {
    // рендеринг компонента
  }
}
```
Обратите внимание, что метод shouldComponentUpdate() может повлиять на производительность приложения, поэтому его следует использовать с осторожностью и только там, где это необходимо.

> Как я могу реализовать shouldComponentUpdate? Вы можете обернуть функциональный компонент в вызов **React.memo** для поверхностного сравнения его пропсов:
```js
const Button = React.memo((props) => {
  // ваш компонент
});
```
Эта функция не является хуком, так как она не ведёт себя как хук. React.memo аналогична PureComponent, но она сравнивает только пропсы. (Вы также можете добавить второй аргумент, чтобы определить свою функцию сравнения, которая примет старые и новые пропсы. Если эта функция вернёт true, обновление будет пропущено.)

React.memo не сравнивает состояние, потому что не существует единого объекта, который можно сравнить. Но вы можете также сделать дочерние компоненты чистыми или даже оптимизировать определённые дочерние компоненты, используя хук useMemo.

[вернуться к списку вопросов](#0)
***

<a id="8"></a>
## Можно ли использовать стрелочные функции в методе render()?

В целом, да. Зачастую это самый простой способ передать параметры через колбэки.
Однако, если вы используете стрелочную функцию в качестве метода класса, то контекст this будет ссылаться на объект, в котором определена функция, а не на экземпляр класса. Это может привести к ошибкам, если вы пытаетесь обратиться к свойствам или методам экземпляра класса. Чтобы избежать этой проблемы, вы можете использовать обычные функции вместо стрелочных функций в методах класса.

[вернуться к списку вопросов](#0)
***

# React-interview

<a id="0"/></a>

[1. Что такое JSX?](#1)

[2. Можно ли использовать React без JSX?](#2)

[3. Что такое виртуальный DOM?](#3)

[4. Является ли виртуальный DOM таким же, как теневой DOM?](#4)

[5. В чем разница между виртуальным DOM и реальным DOM?](#5)

[6. Когда рендерится компонент?](#6)

[7. Как не рендерить при изменении props?](#7)

[8. Можно ли использовать стрелочные функции в методе render()?](#8)

[9. Как передать значение от родителя к дочернему?](#9)

[10. Как передать значение от дочернего к родительскому?](#10)

[11. Что такое prop drilling?](#11)

[12. Может ли дочерний компонент изменять свои props?](#12)

[13. Rак передать значения между соседними компонентами (siblings)?](#13)

[14. В чем разница между props и state?](#14)

***

<a id="1"/></a>
## 1. Что такое JSX?

**JSX** - это расширение синтаксиса JavaScript, которое позволяет использовать XML-подобный синтаксис для описания структуры пользовательского интерфейса в React. JSX позволяет разработчикам создавать компоненты React, которые могут содержать HTML-подобные теги, атрибуты и дочерние элементы. JSX затем компилируется в обычный JavaScript, который может быть выполнен в браузере. 

**JSX** понимается только препроцессорами, такими как Babel. Когда препроцессор обрабатывает этот текст, похожий на HTML, он преобразуется в обычные функциональные вызовы React.createElement.

> JSX не является частью спецификации ECMAScript, и поэтому ни один веб-браузер не понимает JSX.
JSX - это синтаксический сахар для функции React.createElement.

Вот пример использования JSX в React:

```js
import React from 'react';

function MyComponent() {
  return (
    <div className="my-class">
      <h1>Hello, World!</h1>
      <p>This is my first React component.</p>
    </div>
  );
}
```

В этом примере мы создаем компонент MyComponent, который возвращает JSX-элемент, содержащий теги div, h1 и p. Обратите внимание, что мы используем атрибут className вместо class, потому что class является зарезервированным словом в JavaScript.

[вернуться к списку вопросов](#0)
***

<a id="2"/></a>
## 2. Можно ли использовать React без JSX?

Да, можно использовать React без JSX. JSX - это просто синтаксический сахар, который упрощает написание кода React, но не является обязательным для использования React. Вместо JSX вы можете использовать обычный JavaScript для создания элементов React.

> JSX - это синтаксический сахар для функции React.createElement. React.createElement является частью общедоступного API верхнего уровня React, так же как React.component или React.useRef.

Например, вместо написания:
```js
const element = <h1>Hello, world!</h1>;

// Вы можете написать:

const element = React.createElement('h1', null, 'Hello, world!');
```

Обратите внимание, что React.createElement() возвращает объект React-элемента, который затем может быть отрендерен в DOM.

[вернуться к списку вопросов](#0)
***
<a id="3"/></a>
## 3. Что такое виртуальный DOM? Как React использует виртуальный DOM для рендеринга пользовательского интерфейса?
> Объектная модель документа (Document Object Model, DOM) - это стандартная модель программирования, используемая для представления и взаимодействия с HTML-документами, XML-документами и другими типами документов. DOM представляет документ в виде дерева объектов, где каждый элемент документа является объектом. DOM простыми словами представляет собой пользовательский интерфейс приложения.

> Виртуальный DOM — это виртуальное представление реального DOM.

**Виртуальный DOM (VDOM)** - это концепция, которая используется во многих библиотеках и фреймворках JavaScript, включая React. Он представляет собой абстрактное представление реального DOM, которое хранится в памяти и используется для оптимизации процесса рендеринга.

Когда React обновляет пользовательский интерфейс, он сначала создает новое дерево виртуального DOM на основе изменений в состоянии приложения или свойствах компонентов. Затем React сравнивает новое дерево виртуального DOM с предыдущим деревом и определяет, какие элементы были изменены, добавлены или удалены.

После того, как React определил, какие элементы должны быть обновлены, он создает новый дерево реального DOM и обновляет только те элементы, которые были изменены. Это позволяет избежать необходимости полного перерисовывания всего пользовательского интерфейса и ускоряет процесс рендеринга.

Использование виртуального DOM также позволяет React работать с различными браузерами и платформами, не завися от конкретной реализации реального DOM. Это делает React более переносимым и удобным для разработки кросс-браузерных приложений.

В целом, использование виртуального DOM является одним из ключевых преимуществ React и позволяет создавать быстрые и эффективные пользовательские интерфейсы.

[вернуться к списку вопросов](#0)
***
<a id="4"/></a>
## 4. Является ли виртуальный DOM таким же, как теневой DOM?

**Виртуальный DOM (virtual DOM, VDOM)** - это концепция, используемая в библиотеках и фреймворках, таких как React и Vue, для оптимизации производительности при обновлении пользовательского интерфейса. Виртуальный DOM представляет собой виртуальное дерево элементов, которое React или Vue используют для определения того, какие элементы должны быть обновлены при изменении состояния приложения. Виртуальный DOM позволяет избежать ненужных обновлений и повысить производительность приложения.

**Теневой DOM (shadow DOM)** - это концепция, используемая в браузерах для реализации веб-компонентов. Теневой DOM представляет собой отдельное дерево элементов, которое используется для изоляции стилей и поведения веб-компонента от остальной части страницы. Теневой DOM позволяет создавать компоненты, которые могут быть использованы в разных частях страницы, не влияя на другие элементы на странице.

Таким образом, виртуальный DOM и теневой DOM - это разные концепции, используемые для разных целей.

[вернуться к списку вопросов](#0)
***
<a id="5"/></a>
## 5. В чем разница между виртуальным DOM и реальным DOM?

**Виртуальный DOM (VDOM)** - это концепция, которая используется в библиотеках и фреймворках JavaScript, таких как React и Vue, для ускорения процесса обновления пользовательского интерфейса. Вместо того, чтобы изменять реальный DOM напрямую, библиотеки создают виртуальное представление дерева DOM, которое хранится в памяти. Когда происходят изменения в состоянии приложения, библиотека сравнивает виртуальное дерево с предыдущей версией и определяет, какие элементы необходимо обновить. Затем библиотека обновляет только те элементы, которые изменились, в реальном DOM.

**Реальный DOM** - это фактическое представление дерева DOM, которое браузер создает на основе HTML-кода. Когда происходят изменения в состоянии приложения, библиотеки обновляют реальный DOM, чтобы отобразить эти изменения. Однако обновление реального DOM может быть очень медленным, особенно если в дереве DOM много элементов. Кроме того, обновление реального DOM может привести к перерисовке всего дерева, даже если изменения затрагивают только небольшую часть дерева.

Виртуальный DOM позволяет избежать этих проблем, поскольку он позволяет библиотекам эффективно обновлять только те элементы, которые изменились, и не перерисовывать всё дерево. Это делает обновление пользовательского интерфейса более быстрым и эффективным.

![img](assets/VDOM.png)

[вернуться к списку вопросов](#0)
***
<a id="6"></a>
## 6. Когда рендерится компонент?
Компонент рендерится, когда он вставляется в DOM. Это происходит, когда компонент впервые отображается на странице или когда его состояние или свойства изменяются. Когда компонент рендерится, React создает виртуальное представление дерева DOM, которое затем сравнивается с предыдущей версией, чтобы определить, какие элементы необходимо обновить. Затем React обновляет только те элементы, которые изменились, в реальном DOM.

Компонент может быть перерендерен множество раз во время жизненного цикла приложения, например, когда его состояние или свойства изменяются, или когда он получает новые данные из API. При этом React будет создавать новое виртуальное представление дерева DOM и сравнивать его с предыдущей версией, чтобы определить, какие элементы необходимо обновить. Если изменения затрагивают только небольшую часть дерева, то React обновит только эту часть, что делает обновление пользовательского интерфейса более быстрым и эффективным.

[вернуться к списку вопросов](#0)
***
<a id="7"></a>
## 7. Как не рендерить при изменении props?
> Использовать метод жизненного цикла **shouldComponentUpdate()**

Этот метод вызывается перед каждым обновлением компонента и позволяет определить, должен ли компонент быть перерендерен или нет.

В методе shouldComponentUpdate() вы можете сравнить текущие свойства (props) компонента с предыдущими свойствами и вернуть false, если свойства не изменились и компонент не должен быть перерендерен. Если свойства изменились, вы можете вернуть true, чтобы разрешить перерендеринг компонента.

Вот пример использования метода shouldComponentUpdate() для предотвращения перерендеривания компонента при изменении определенных свойств:
```js
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps) {
    if (nextProps.prop1 === this.props.prop1 && nextProps.prop2 === this.props.prop2) {
      return false; // не перерендеривать компонент, если prop1 и prop2 не изменились
    }
    return true; // перерендеривать компонент, если prop1 или prop2 изменились
  }

  render() {
    // рендеринг компонента
  }
}
```
Обратите внимание, что метод shouldComponentUpdate() может повлиять на производительность приложения, поэтому его следует использовать с осторожностью и только там, где это необходимо.

> Как я могу реализовать shouldComponentUpdate? Вы можете обернуть функциональный компонент в вызов **React.memo** для поверхностного сравнения его пропсов:
```js
const Button = React.memo((props) => {
  // ваш компонент
});
```
Эта функция не является хуком, так как она не ведёт себя как хук. React.memo аналогична PureComponent, но она сравнивает только пропсы. (Вы также можете добавить второй аргумент, чтобы определить свою функцию сравнения, которая примет старые и новые пропсы. Если эта функция вернёт true, обновление будет пропущено.)

React.memo не сравнивает состояние, потому что не существует единого объекта, который можно сравнить. Но вы можете также сделать дочерние компоненты чистыми или даже оптимизировать определённые дочерние компоненты, используя хук useMemo.

[вернуться к списку вопросов](#0)
***

<a id="8"></a>
## 8. Можно ли использовать стрелочные функции в методе render()?

В целом, да. Зачастую это самый простой способ передать параметры через колбэки.
Однако, если вы используете стрелочную функцию в качестве метода класса, то контекст this будет ссылаться на объект, в котором определена функция, а не на экземпляр класса. Это может привести к ошибкам, если вы пытаетесь обратиться к свойствам или методам экземпляра класса. Чтобы избежать этой проблемы, вы можете использовать обычные функции вместо стрелочных функций в методах класса.

[вернуться к списку вопросов](#0)
***

<a id="9"></a>
## 9. Как передать значение от родителя к дочернему?

Вы можете передать значение от родительского компонента к дочернему компоненту в React, используя пропсы (props). 
> props (пропсы) — это входные данные React-компонентов, передаваемые от родительского компонента дочернему компоненту.

Помните, props предназначены только для чтения. Ни в каком случае их не следует изменять.

```js
// Родительский компонент
function ParentComponent() {
  const value = "Hello, world!";

  return (
    <ChildComponent message={value} />
  );
}

// Дочерний компонент
function ChildComponent(props) {
  return (
    <div>{props.message}</div>
  );
}
```

В этом примере мы определяем переменную value в родительском компоненте и передаем ее значение в дочерний компонент через атрибут message. В дочернем компоненте мы выводим значение пропса message внутри элемента div.

Вы также можете передавать функции в качестве пропсов, чтобы дочерний компонент мог вызывать их для обновления состояния родительского компонента.

[вернуться к списку вопросов](#0)
***

<a id="10"></a>
## 10. Как передать значение от дочернего к родительскому?

Чтобы передать значение от дочернего компонента к родительскому компоненту в React, вы можете использовать **колбэки**.

Для передачи значения от дочернего компонента к родительскому компоненту, вы можете определить колбэк в родительском компоненте и передать его в дочерний компонент через пропсы. В дочернем компоненте вы можете вызвать этот колбэк с передачей значения в качестве аргумента. 

Например:
```js
// Родительский компонент
function ParentComponent() {
  const [value, setValue] = useState("");

  function handleChildValue(newValue) {
    setValue(newValue);
  }

  return (
    <div>
      <ChildComponent onValueChange={handleChildValue} />
      <p>Value from child: {value}</p>
    </div>
  );
}

// Дочерний компонент
function ChildComponent(props) {
  function handleChange(event) {
    props.onValueChange(event.target.value);
  }

  return (
    <input type="text" onChange={handleChange} />
  );
}
```
В этом примере мы определяем состояние value в родительском компоненте и передаем колбэк handleChildValue в дочерний компонент через пропс onValueChange. В дочернем компоненте мы определяем функцию handleChange, которая вызывает колбэк onValueChange с передачей значения из поля ввода в качестве аргумента. Когда значение изменяется в дочернем компоненте, вызывается колбэк handleChildValue в родительском компоненте, который обновляет состояние value.

[вернуться к списку вопросов](#0)
***

<a id="11"></a>
## 11. Что такое prop drilling (сверление пропсов)?

> "Prop drilling" - это процесс передачи пропсов (props) через несколько уровней вложенных компонентов в React (более чем на два). 

Когда компоненты находятся на разных уровнях вложенности, и один компонент должен передать данные другому компоненту, который находится глубоко внутри дерева компонентов, то необходимо передавать пропсы через все промежуточные компоненты, что может привести к "prop drilling".

"Prop drilling" может быть проблемой, когда приложение становится сложным и имеет множество вложенных компонентов. В таких случаях передача пропсов через множество уровней может стать неудобной и привести к ошибкам. Для решения этой проблемы можно использовать более продвинутые методы передачи данных, такие как контекст (context) или Redux.

[вернуться к списку вопросов](#0)
***

<a id="12"></a>
## 12. Может ли дочерний компонент изменять свои props?

Нет, дочерний компонент не может изменять свои пропсы (props) напрямую. В React пропсы являются неизменяемыми (immutable) и только родительский компонент может изменять свои пропсы и передавать их дочерним компонентам.

Однако, если дочерний компонент должен изменять какие-то данные, которые были переданы ему через пропсы, то родительский компонент может передать функцию обратного вызова (callback function) в качестве пропса, которая будет вызываться в дочернем компоненте для изменения данных. Таким образом, дочерний компонент может изменять данные, но только через вызов функции обратного вызова, которая была передана ему через пропсы.

[вернуться к списку вопросов](#0)
***

<a id="13"></a>
## 13. Как передать значения между соседними компонентами (siblings)?

В React данные передаются вниз по иерархии компонентов, от родительского компонента к дочерним компонентам через пропсы (props). Если два компонента являются соседними (siblings) и не имеют общего родительского компонента, то можно использовать подход "поднятия состояния вверх" (lifting state up).

Поднятие состояния вверх - это процесс перемещения состояния из дочернего компонента в родительский компонент, чтобы обеспечить доступ к этому состоянию другим дочерним компонентам. Для этого необходимо определить состояние в родительском компоненте и передавать его в качестве пропса в дочерние компоненты. Если два соседних компонента должны иметь доступ к одному и тому же состоянию, то это состояние должно быть определено в их общем родительском компоненте.

[вернуться к списку вопросов](#0)
***

<a id="14"></a>
## 14. В чем разница между props и state?

В React props и state используются для управления данными и поведением компонентов.

> Props (сокращение от properties) - это объекты, которые передаются в компоненты в качестве атрибутов. Они используются для передачи данных от родительского компонента к дочернему компоненту. Props являются неизменяемыми и доступны только для чтения в компоненте, в котором они были переданы.

> State - это объект, который содержит данные, управляющие поведением компонента. State может изменяться внутри компонента и обновляться с помощью метода setState(). Когда state изменяется, React перерисовывает компонент, чтобы отобразить новое состояние.

Основная разница между props и state заключается в том, что props передаются в компонент извне, а state управляется самим компонентом. Props используются для передачи данных от родительского компонента к дочернему компоненту, а state используется для управления поведением компонента внутри него.




